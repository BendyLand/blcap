// main.cpp
#include <iostream>
#include "os.hpp"
#include "mystl.hpp"
#include "utils.hpp"

int run(int argc, char** argv);

int main(int argc, char** argv)
{
    if (argc > 1) {
        int res = run(argc, argv);
        return res;
    }
    else {
        std::cout << "Usage: blcap <video_file>" << std::endl;
        return 1;
    }
}

int run(int argc, char** argv)
{
    std::string filename = argv[1];
    std::string output = get_output_name(filename) + ".wav";
    std::string hw_encoder;
    std::string encoding_flag;
#if defined(OS_MACOS)
    hw_encoder = "auto";
    encoding_flag = " -c:v h264_videotoolbox ";
#elif defined(OS_LINUX)
    hw_encoder = "vaapi";
    encoding_flag = " -c:v h264_vaapi -vf 'format=nv12,hwupload' ";
#elif defined(OS_WINDOWS)
    hw_encoder = "qsv";
    encoding_flag = " -c:v h264_qsv ";
#else
    hw_encoder = "auto";
    encoding_flag = " ";
#endif
    std::string extraction_cmd = get_extraction_cmd(hw_encoder, filename, encoding_flag, output);
    std::pair<int, std::string> res = OS::run_command(extraction_cmd);
    if (res.first != 0) log_err_and_exit("There was a problem extracting the transcript from the video.", res.second);

    // The whisper command is: <path>/<to>/whisper-cpp/build/bin/whisper-cli -m <path>/<to>/whisper-cpp/models/ggml-base.en.bin -f <WAV_file>
    std::string whisper_cmd = read_file("whisper-cmd.txt") + output;
    res = OS::run_command(whisper_cmd);
    if (res.first != 0) log_err_and_exit("There was a problem running Whisper.", res.second);

    std::cout << "Getting transcription..." << std::endl;
    std::string transcription = get_transcription(res.second);
    std::cout << "Transcription:\n" << transcription << "\n" << std::endl;

    std::cout << "Converting to SRT format..." << std::endl;
    transcription = transcription_to_srt(transcription);
    std::cout << "Transcription converted successfully!\n" << std::endl;

    std::cout << "Writing SRT file..." << std::endl;
    write_file("transcript.srt", transcription);
    std::cout << "File written successfully!\n" << std::endl;

    // Absolute path where `transcript.srt` can be found.
    std::string transcript_path = read_file("transcript-path.txt");
    std::string caption_cmd = get_caption_cmd(argc, argv, hw_encoder, filename, encoding_flag, transcript_path);
    if (caption_cmd == "SRT_ONLY") {
        std::string remove_cmd = "rm " + output;
        res = OS::run_command(remove_cmd);
        std::cout << "Captions written to 'transcript.srt'!\n" << std::endl;
        return res.first;
    }
    std::cout << "Embedding captions..." << std::endl;
    res = OS::run_command(caption_cmd);
    if (res.first == 0) std::cout << "Captions added successfully!\n" << std::endl;
    else std::cerr << "An error occurred when adding captions.\n" << std::endl;

    res = remove_temp_file("transcript.srt");
    std::string remove_cmd = "rm " + output;
    res = OS::run_command(remove_cmd);
    return res.first;
}

// os.cpp
#include "os.hpp"

std::string OS::detect_os()
{
    std::string result;
    #if defined(OS_WINDOWS)
        result = "Windows";
    #elif defined(OS_MACOS)
        result = "MacOS";
    #elif defined(OS_LINUX)
        result = "Linux";
    #elif defined(OS_UNIX)
        result = "Unix";
    #elif defined(OS_FREEBSD)
        result = "FreeBSD";
    #else
        result = "Unknown";
    #endif
    return result;
}

#if OS_UNIX_LIKE_DEFINED
std::pair<int, std::string> OS::run_command_unix(const std::vector<std::string>& args)
{
    // Convert std::vector<std::string> to an array of char* required by execvp
    std::vector<char*> cargs;
    for (const std::string& arg : args) {
        cargs.push_back(strdup(arg.c_str()));
    }
    cargs.push_back(nullptr);  // execvp expects a null-terminated array
    int pipefd[2];  // Pipe for capturing output
    if (pipe(pipefd) == -1) {
        perror("pipe failed");
        return {-1, ""};
    }
    pid_t pid = fork();  // Fork the current process
    if (pid == -1) {
        // Error occurred during fork
        perror("fork failed");
        return {-1, ""};
    }
    else if (pid == 0) {
        // Child process: redirect stdout to the pipe
        close(pipefd[0]);  // Close unused read end
        dup2(pipefd[1], STDOUT_FILENO);  // Redirect stdout to pipe write end
        dup2(pipefd[1], STDERR_FILENO);  // Optionally redirect stderr to pipe write end
        close(pipefd[1]);  // Close original write end after duplication
        execvp(cargs[0], cargs.data());
        // execvp only returns if an error occurred
        perror("execvp failed");
        exit(EXIT_FAILURE);
    }
    else {
        // Parent process
        close(pipefd[1]);  // Close unused write end
        // Read output from the pipe
        std::string output;
        char buffer[128];
        ssize_t bytesRead;
        while ((bytesRead = read(pipefd[0], buffer, sizeof(buffer) - 1)) > 0) {
            buffer[bytesRead] = '\0';
            output += buffer;
        }
        close(pipefd[0]);  // Close read end when done
        // Wait for the child process to finish
        int status;
        waitpid(pid, &status, 0);  // Wait for the child process to terminate
        // Free allocated memory for cargs
        for (char* carg : cargs) {
            free(carg);
        }
        // Return child's exit status and captured output
        if (WIFEXITED(status)) {
            return {WEXITSTATUS(status), output};  // Return exit code and output
        }
        else {
            return {-1, output};  // Child did not exit normally, return -1 with captured output
        }
    }
}
#elif OS_WINDOWS_DEFINED || !OS_UNIX_LIKE_DEFINED
std::pair<int, std::string> OS::run_command_windows(const std::string& command)
{
    PROCESS_INFORMATION processInfo = {};
    STARTUPINFO startupInfo = { sizeof(STARTUPINFO) };
    SECURITY_ATTRIBUTES securityAttrs = { sizeof(SECURITY_ATTRIBUTES), NULL, TRUE };
    HANDLE hRead = NULL, hWrite = NULL;

    // Create pipe for capturing output
    if (!CreatePipe(&hRead, &hWrite, &securityAttrs, 0)) {
        return {-1, "Failed to create pipe"};
    }

    startupInfo.hStdOutput = hWrite;
    startupInfo.hStdError = hWrite;
    startupInfo.dwFlags |= STARTF_USESTDHANDLES;

    // Use cmd.exe to execute the command
    std::string fullCommand = "cmd.exe /C " + command;

    // Create a modifiable command string
    char commandBuffer[2048];
    strncpy(commandBuffer, fullCommand.c_str(), sizeof(commandBuffer) - 1);
    commandBuffer[sizeof(commandBuffer) - 1] = '\0';

    // Execute command
    if (!CreateProcess(
            NULL,               // Application name
            commandBuffer,      // Command line
            NULL,               // Process security attributes
            NULL,               // Thread security attributes
            TRUE,               // Inherit handles
            0,                  // Creation flags
            NULL,               // Environment
            NULL,               // Current directory
            &startupInfo,       // Startup info
            &processInfo))      // Process info
    {
        CloseHandle(hRead);
        CloseHandle(hWrite);
        DWORD error = GetLastError();
        return {-1, "Failed to create process. Error code: " + std::to_string(error)};
    }

    // Close the write end of the pipe in the parent process
    CloseHandle(hWrite);

    // Wait for the process to complete and read the output
    WaitForSingleObject(processInfo.hProcess, INFINITE);

    char buffer[128];
    std::string output;
    DWORD bytesRead;
    while (ReadFile(hRead, buffer, sizeof(buffer) - 1, &bytesRead, NULL) && bytesRead > 0) {
        buffer[bytesRead] = '\0'; // Null-terminate
        output += buffer;
    }
    CloseHandle(hRead);

    // Get the exit code of the process
    DWORD exitCode = 0;
    if (!GetExitCodeProcess(processInfo.hProcess, &exitCode)) {
        exitCode = -1; // Error retrieving exit code
    }

    // Clean up handles
    CloseHandle(processInfo.hProcess);
    CloseHandle(processInfo.hThread);

    return {static_cast<int>(exitCode), output};
}
#endif

std::pair<int, std::string> OS::run_command(std::string& arg)
{
    std::pair<int, std::string> result;
    std::vector<std::string> args = split(arg, ' ');
    #if defined(OS_UNIX_LIKE)
        result = OS::run_command_unix(args);
    #else
        result = OS::run_command_windows(arg);
    #endif
    return result;
}

std::vector<std::string> split(std::string str, char delim)
{
    std::vector<std::string> result;
    std::string temp = "";
    for (char c : str) {
        if (c == delim) {
            result.emplace_back(temp);
            temp = "";
            continue;
        }
        temp += c;
    }
    if (temp.size() > 0) result.emplace_back(temp);
    return result;
}

// utils.cpp
#include "utils.hpp"

using str_arg = const std::string&;

std::string format_str(const std::string text, ...)
{
    va_list args;
    va_start(args, text);
    int size = vsnprintf(nullptr, 0, text.c_str(), args); // Get required size
    va_end(args); // `args` is consumed here
    if (size < 0) return "";
    std::string buffer(size, '\0'); // Allocate std::string with correct size
    va_list args2;
    va_start(args2, text);
    vsnprintf(&buffer[0], size + 1, text.c_str(), args2); // Fill buffer
    va_end(args2);
    return buffer;
}

std::string get_output_name(str_arg input_file)
{
    size_t pos = input_file.find(".");
    if (pos == -1) return input_file;
    return input_file.substr(0, pos);
}

int transcribe_audio(str_arg audioFile, str_arg transcriptFile)
{
    std::string command = "./whisper -m models/medium.en.bin -f " + audioFile + " -otxt";
    return system(command.c_str());
}

std::string read_file(str_arg filename)
{
    std::ifstream file(filename); // Open in read mode
    if (!file) {
        std::cerr << "Error opening file: " << filename << std::endl;
        exit(1);
    }
    return std::string((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());
}

void write_file(str_arg filename, str_arg text)
{
    std::ofstream file(filename.c_str());
    if (file.is_open()) {
        file << text;
        return;
    }
    std::cerr << "Error opening file" << std::endl;
    exit(1);
}

std::string get_transcription(str_arg output)
{
    my::string temp = output;
    my::vector<my::string> lines = temp.split("\n");
    my::vector<my::string> temp_vec;
    for (const my::string& line : lines) {
        if (line.str().starts_with("[")) temp_vec.emplace(line);
    }
    return temp_vec.join("\n");
}

my::string convert_line(const my::string& line, size_t current)
{
    size_t end_bracket = line.str().find("]") + 1;
    my::string timestamp = line.str().substr(0, end_bracket);
    while (timestamp.contains(".")) {
        size_t pos = timestamp.str().find(".");
        timestamp[pos] = ',';
    }
    timestamp = timestamp.str().substr(1, timestamp.size()-2);
    my::string text = line.str().substr(end_bracket+1);
    text = text.trim();
    my::string result = format_str("%d\n%s\n%s", current, timestamp.str().c_str(), text.str().c_str());
    return result;
}

std::string transcription_to_srt(str_arg transcript)
{
    my::string temp = transcript;
    my::vector<my::string> lines = temp.split("\n");
    size_t current = 1;
    my::vector<my::string> temp_vec;
    for (my::string line : lines) {
        my::string new_line = convert_line(line, current++);
        temp_vec.emplace(new_line);
    }
    return temp_vec.join("\n\n").trim();
}

std::string get_caption_cmd(int argc, char** argv, str_arg hw_encoder, str_arg filename, str_arg encoding_flag, str_arg transcript_path)
{
    std::string result;
    if (argc > 2) {
        Flag f = parse_flags(argc, argv);
        switch (f) {
        case Flag::BURN:
            result = construct_burn_cmd(hw_encoder, filename, encoding_flag, transcript_path);
            break;
        case Flag::SRT_ONLY:
            result = "SRT_ONLY";
            break;
        default:
            std::cout << "Invlaid flag." << std::endl;
            break;
        }
    }
    else {
        result = format_str(
            "ffmpeg -y -i %s -i %s -c:v copy -c:a copy -c:s mov_text %s_w_captions.mp4",
            filename.c_str(),
            transcript_path.c_str(),
            get_output_name(filename).c_str()
        );
    }
    return result;
}

std::string construct_burn_cmd(str_arg hw_encoder, str_arg filename, str_arg encoding_flag, str_arg transcript_path)
{
    std::string result;
    result = format_str(
        "ffmpeg -y -hwaccel %s -i %s%s-vf subtitles=%s -c:a copy %s_w_captions.mp4",
        hw_encoder.c_str(),
        filename.c_str(),
        encoding_flag.c_str(),
        transcript_path.c_str(),
        get_output_name(filename).c_str()
    );
    return result;
}

std::string get_flag(const char* arg)
{
    std::string result = "";
    size_t len = strlen(arg);
    bool flag_start = false;
    for (size_t i = 0; i < len; i++) {
        if (arg[i] != '-') flag_start = true;
        if (flag_start) result += arg[i];
    }
    return result;
}

std::string get_extraction_cmd(str_arg hw_encoder, str_arg filename, str_arg encoding_flag, str_arg output)
{
    std::string result = format_str(
        "ffmpeg -y -hwaccel %s -i %s%s-vn -acodec pcm_s16le -ar 16000 -ac 1 %s",
        hw_encoder.c_str(),
        filename.c_str(),
        encoding_flag.c_str(),
        output.c_str()
    );
    return result;
}

void log_err_and_exit(str_arg text, str_arg err_message)
{
    std::cerr << text << std::endl;
    std::cerr << err_message << std::endl;
    exit(1);
}

Flag parse_flags(int argc, char** argv) 
{
    for (size_t i = 1; i < argc; i++) {
        std::string flag = get_flag(argv[i]);
        if (flag == "burn") return Flag::BURN;
        if (flag == "srt-only") return Flag::SRT_ONLY;
    }
    return Flag::SOFT; 
}

std::pair<int, std::string> remove_temp_file(str_arg filepath) 
{
#if defined(OS_WINDOWS)
    std::string cmd = "del /F /Q " + filepath;
#else
    std::string cmd = "rm -f " + filepath;
#endif
    std::pair<int, std::string> res = OS::run_command(cmd);
    return res;
}
